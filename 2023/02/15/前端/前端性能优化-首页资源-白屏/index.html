<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端/前端性能优化-首页资源-白屏 | 小黑的小站</title><meta name="description" content="提升首屏的加载速度，是前端性能优化中最重要的环节，这里笔者梳理出一些 常规且有效 的首屏优化建议 目标： 通过对比优化前后的性能变化，来验证方案的有效性，了解并掌握其原理 1、路由懒加载SPA 项目，一个路由对应一个页面，如果不做处理，项目打包后，会把所有页面打包成一个文件，当用户打开首页时，会一次性加载所有的资源，造成首页加载很慢，降低用户体验 列一个实际项目的打包详情：  app.js 初始"><meta name="author" content="小黑"><meta name="copyright" content="小黑"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="前端/前端性能优化-首页资源-白屏"><meta name="twitter:description" content="提升首屏的加载速度，是前端性能优化中最重要的环节，这里笔者梳理出一些 常规且有效 的首屏优化建议 目标： 通过对比优化前后的性能变化，来验证方案的有效性，了解并掌握其原理 1、路由懒加载SPA 项目，一个路由对应一个页面，如果不做处理，项目打包后，会把所有页面打包成一个文件，当用户打开首页时，会一次性加载所有的资源，造成首页加载很慢，降低用户体验 列一个实际项目的打包详情：  app.js 初始"><meta name="twitter:image" content="http://yoursite.com/img/javascript.jpg"><meta property="og:type" content="article"><meta property="og:title" content="前端/前端性能优化-首页资源-白屏"><meta property="og:url" content="http://yoursite.com/2023/02/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A6%96%E9%A1%B5%E8%B5%84%E6%BA%90-%E7%99%BD%E5%B1%8F/"><meta property="og:site_name" content="小黑的小站"><meta property="og:description" content="提升首屏的加载速度，是前端性能优化中最重要的环节，这里笔者梳理出一些 常规且有效 的首屏优化建议 目标： 通过对比优化前后的性能变化，来验证方案的有效性，了解并掌握其原理 1、路由懒加载SPA 项目，一个路由对应一个页面，如果不做处理，项目打包后，会把所有页面打包成一个文件，当用户打开首页时，会一次性加载所有的资源，造成首页加载很慢，降低用户体验 列一个实际项目的打包详情：  app.js 初始"><meta property="og:image" content="http://yoursite.com/img/javascript.jpg"><meta property="article:published_time" content="2023-02-15T08:30:05.097Z"><meta property="article:modified_time" content="2023-02-15T08:35:09.667Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2023/02/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A6%96%E9%A1%B5%E8%B5%84%E6%BA%90-%E7%99%BD%E5%B1%8F/"><link rel="prev" title="后端/SQL基础" href="http://yoursite.com/2023/02/15/%E5%90%8E%E7%AB%AF/SQL%E5%9F%BA%E7%A1%80/"><link rel="next" title="前端/前端性能优化-包体积" href="http://yoursite.com/2023/02/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8C%85%E4%BD%93%E7%A7%AF/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://ynxh.xyz","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">127</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、路由懒加载"><span class="toc-number">1.</span> <span class="toc-text">1、路由懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#路由懒加载的原理"><span class="toc-number">1.1.</span> <span class="toc-text">路由懒加载的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、组件懒加载"><span class="toc-number">2.</span> <span class="toc-text">2、组件懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#组件懒加载的使用场景"><span class="toc-number">2.1.</span> <span class="toc-text">组件懒加载的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、合理使用-Tree-shaking"><span class="toc-number">3.</span> <span class="toc-text">3、合理使用 Tree shaking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree-shaking-并不是万能的"><span class="toc-number">3.1.</span> <span class="toc-text">Tree shaking 并不是万能的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、骨架屏优化白屏时长"><span class="toc-number">4.</span> <span class="toc-text">4、骨架屏优化白屏时长</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#骨架屏插件"><span class="toc-number">4.1.</span> <span class="toc-text">骨架屏插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、长列表虚拟滚动"><span class="toc-number">5.</span> <span class="toc-text">5、长列表虚拟滚动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟滚动插件"><span class="toc-number">5.1.</span> <span class="toc-text">虚拟滚动插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、Web-Worker-优化长任务"><span class="toc-number">6.</span> <span class="toc-text">6、Web Worker 优化长任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Worker-的通信时长"><span class="toc-number">6.1.</span> <span class="toc-text">Web Worker 的通信时长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、requestAnimationFrame-制作动画"><span class="toc-number">7.</span> <span class="toc-text">7、requestAnimationFrame 制作动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、JS-的-6-种加载方式"><span class="toc-number">8.</span> <span class="toc-text">8、JS 的 6 种加载方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）正常模式"><span class="toc-number">8.1.</span> <span class="toc-text">1）正常模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2）async-模式"><span class="toc-number">8.2.</span> <span class="toc-text">2）async 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3）defer-模式"><span class="toc-number">8.3.</span> <span class="toc-text">3）defer 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4）module-模式"><span class="toc-number">8.4.</span> <span class="toc-text">4）module 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5）-preload"><span class="toc-number">8.5.</span> <span class="toc-text">5） preload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6）prefetch"><span class="toc-number">8.6.</span> <span class="toc-text">6）prefetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载方式总结"><span class="toc-number">8.7.</span> <span class="toc-text">加载方式总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、图片的优化"><span class="toc-number">9.</span> <span class="toc-text">9、图片的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图片的动态裁剪"><span class="toc-number">9.1.</span> <span class="toc-text">图片的动态裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片的懒加载"><span class="toc-number">9.2.</span> <span class="toc-text">图片的懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用字体图标"><span class="toc-number">9.3.</span> <span class="toc-text">使用字体图标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片转-base64-格式"><span class="toc-number">9.4.</span> <span class="toc-text">图片转 base64 格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化总结"><span class="toc-number">10.</span> <span class="toc-text">优化总结</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/javascript.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">小黑的小站</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">前端/前端性能优化-首页资源-白屏</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2023-02-15 16:30:05"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2023-02-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-02-15 16:35:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-02-15</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.3k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 18 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=OWVlZjdkN2E3ZDQxNjg4YzY5M2E2NTM3M2M1N2RlMTdfaml3WENMYU9RUmJ1bXVrMzN2NjFxcGlRdm80V1RyYmtfVG9rZW46Ym94Y25JNUdBYzJTUndZSkQ4Z21rbjhuMHloXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>提升首屏的加载速度，是前端性能优化中<strong>最重要</strong>的环节，这里笔者梳理出一些 <code>常规且有效</code> 的首屏优化建议</p>
<p><strong>目标：</strong> 通过对比优化前后的性能变化，来验证方案的有效性，了解并掌握其原理</p>
<h2 id="1、路由懒加载"><a href="#1、路由懒加载" class="headerlink" title="1、路由懒加载"></a>1、路由懒加载</h2><p>SPA 项目，一个路由对应一个页面，如果不做处理，项目打包后，会把所有页面打包成一个文件，<strong>当用户打开首页时，会一次性加载所有的资源</strong>，造成首页加载很慢，降低用户体验</p>
<p>列一个实际项目的打包详情：</p>
<ul>
<li>app.js 初始体积： <code>1175 KB</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFhNDJiNjliNDI0NDk3MjMwZTcwMWJhMGZiNjRlZGZfdUtjOURLb2VKWVJRUFRHbW5hYUlLUG95dkg4Mzc3RFZfVG9rZW46Ym94Y254RThDQlFrejNhWDNBNkYxZ0ZVOVVnXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<ul>
<li>app.css 初始体积： <code>274 KB</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=MmMxYmRlMDFhNGYzN2M0NzdkZmQ5MWRmYTNkYmI4MmFfclQzRVhBUTlWbzd2VHRZbmFJbWpLZ1ZKVkdtUmFVamVfVG9rZW46Ym94Y241ZUkyRUZUWXlWNVFvOWVlMTk2R3BnXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>将路由全部改成懒加载</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 通过webpackChunkName设置分割后代码块的名字</span><br><span class="line">const Home = () =&gt; import(/* webpackChunkName: "home" / "@/views/home/index.vue");</span><br><span class="line">const MetricGroup = () =&gt; import(/ webpackChunkName: "metricGroup" */ "@/views/metricGroup/index.vue");</span><br><span class="line">…………</span><br><span class="line">const routes = [</span><br><span class="line">    &#123;</span><br><span class="line">       path: "/",</span><br><span class="line">       name: "home",</span><br><span class="line">       component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       path: "/metricGroup",</span><br><span class="line">       name: "metricGroup",</span><br><span class="line">       component: MetricGroup</span><br><span class="line">    &#125;,</span><br><span class="line">    …………</span><br><span class="line"> ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>重新打包后，首页资源拆分为 app.js 和 home.js，以及对应的 css 文件</p>
<ul>
<li>app.js：<code>244 KB</code>、 home.js: <code>35KB</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=MTBiZDI4ZTU2ZjAzZDBjYmFiYzNkZjJkODIwODAzNTZfMHAzSFBvREM1R0QyaGo4VXJINVFSQkpoaHp5RjNvYlhfVG9rZW46Ym94Y25nSHB2MHJ4VGJEVDZQUW9nUHo1aFRjXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<ul>
<li>app.css：<code>67 KB</code>、home.css: <code>15KB</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=MTM3MjJiMTliOTZiZDgzMGRjN2ExODgzZmUwZmYwZjBfUnF4dWRtRTlRQXFVU3pxSXhUcFZlY3l5NjIxaWY0d0JfVG9rZW46Ym94Y256R3dnNXJQWUpkWG5YWnJZRHJvZ0FuXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>通过路由懒加载，该项目的首页资源压缩约 <code>52%</code></p>
<h3 id="路由懒加载的原理"><a href="#路由懒加载的原理" class="headerlink" title="路由懒加载的原理"></a>路由懒加载的原理</h3><p>懒加载前提的实现：ES6 的动态地加载模块——<code>import()</code></p>
<blockquote>
<p>调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中 ——摘自<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Fmodule-methods%2F%23import">《webpack——模块方法》的 import()小节</a></p>
</blockquote>
<p>要实现懒加载，就得先将进行懒加载的子模块分离出来，打包成一个单独的文件</p>
<p>webpackChunkName 作用是 webpack 在打包的时候，对异步引入的库代码（lodash）进行代码分割时，设置代码块的名字。webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中</p>
<h2 id="2、组件懒加载"><a href="#2、组件懒加载" class="headerlink" title="2、组件懒加载"></a>2、组件懒加载</h2><p>除了路由的懒加载外，组件的懒加载在很多场景下也有重要的作用</p>
<p>举个 🌰：</p>
<p>home 页面 和 about 页面，都引入了 dialogInfo 弹框组件，该弹框不是一进入页面就加载，而是需要用户手动触发后才展示出来</p>
<p>home 页面示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"homeView"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>home 页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"dialogVisible = !dialogVisible"</span>&gt;</span>打开弹框<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span><span class="tag">&lt;<span class="name">dialogInfo</span> <span class="attr">v-if</span>=<span class="string">"dialogVisible"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">import</span> dialogInfo <span class="keyword">from</span> <span class="string">'@/components/dialogInfo'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'homeView'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    dialogInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br></pre></td></tr></table></figure>

<p>项目打包后，发现 home.js 和 about.js 均包括了该弹框组件的代码（在 dist 文件中搜索 dialogInfo 弹框组件）</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=ODhiYWFiMDhjNjI5NDcxNTQ3MjQ1ZmVmMDQ5ZDFmY2RfWWVHZE5iZUJhRjNBOTRvbkhPWXF4dXRDUUxLTEt0eXRfVG9rZW46Ym94Y24zQkZ3ZmFSd3Q5Y3J6Vldjcm9XbEFmXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>当用户打开 home 页时，会一次性加载该页面所有的资源，<strong>我们期望的是用户触发按钮后，再加载该弹框组件的资源</strong></p>
<p>这种场景下，就很适合用懒加载的方式引入</p>
<p>弹框组件懒加载：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">const</span> dialogInfo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "dialogInfo" */</span> <span class="string">'@/components/dialogInfo'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'homeView'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    dialogInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br></pre></td></tr></table></figure>

<p>重新打包后，home.js 和 about.js 中没有了弹框组件的代码，该组件被独立打包成 dialogInfo.js，<strong>当用户点击按钮时，才会去加载 dialogInfo.js 和 dialogInfo.css</strong></p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU4OWY4YzQ4ODY0NjFlMTAzMDVlNmIzNzRmOTJlN2NfcUU3Y1pMdk5GaG12aGk2Skt2SHNobUtWVFRaNzBoZXRfVG9rZW46Ym94Y25BYzhwMzZ5dUpCTkJOcUFBVjJJcHRlXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>最终，使用组件路由懒后，该项目的首页资源进一步减少约 <code>11%</code></p>
<h3 id="组件懒加载的使用场景"><a href="#组件懒加载的使用场景" class="headerlink" title="组件懒加载的使用场景"></a>组件懒加载的使用场景</h3><p>有时资源拆分的过细也不好，可能会造成浏览器 http 请求的增多</p>
<p>总结出三种适合组件懒加载的场景：</p>
<p>1）该页面的 JS 文件体积大，导致页面打开慢，可以通过组件懒加载进行资源拆分，利用浏览器并行下载资源，提升下载速度（比如首页）</p>
<p>2）该组件不是一进入页面就展示，需要一定条件下才触发（比如弹框组件）</p>
<p>3）该组件复用性高，很多页面都有引入，利用组件懒加载抽离出该组件，一方面可以很好利用缓存，同时也可以减少页面的 JS 文件大小（比如表格组件、图形组件等）</p>
<h2 id="3、合理使用-Tree-shaking"><a href="#3、合理使用-Tree-shaking" class="headerlink" title="3、合理使用 Tree shaking"></a>3、合理使用 Tree shaking</h2><p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJiMTAyYjZkY2JiZmJiODhjMzdjOTdiMjI1NzY1ZjVfM1hPMUZ5N3hCQ2ppMkdKaW9DRnY5YWJKZnFPc1UyREJfVG9rZW46Ym94Y25PNUo5QlZMTnd4ZzdwQTFEYVFlYnloXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>Tree shaking 的作用：消除无用的 JS 代码，减少代码体积</p>
<p>举个 🌰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.jsexport function targetType(target) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(target));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>项目中只使用了 targetType 方法，但未使用 deepClone 方法，项目打包后，deepClone 方法不会被打包到项目里</p>
<p>tree-shaking 原理：</p>
<p>依赖于 ES6 的模块特性，ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础</p>
<p>静态分析就是不需要执行代码，就可以从字面量上对代码进行分析。ES6 之前的模块化，比如 CommonJS 是动态加载，只有执行后才知道引用的什么模块，就不能通过静态分析去做优化，正是基于这个基础上，才使得 tree-shaking 成为可能</p>
<h3 id="Tree-shaking-并不是万能的"><a href="#Tree-shaking-并不是万能的" class="headerlink" title="Tree shaking 并不是万能的"></a>Tree shaking 并不是万能的</h3><p>并不是说所有无用的代码都可以被消除，还是上面的代码，换个写法 tree-shaking 就失效了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.jsexport default &#123;</span></span><br><span class="line">  targetType(target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase();</span><br><span class="line">  &#125;,</span><br><span class="line">  deepClone(target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(target));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入并使用import util from '../util';</span></span><br><span class="line">util.targetType(<span class="literal">null</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>同样的，项目中只使用了 targetType 方法，未使用 deepClone 方法，项目打包后，deepClone 方法还是被打包到项目里</p>
<p>在 dist 文件中搜索 deepClone 方法：</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=NTNlNzQ3ZDAxZTkzOTI0NGI3ZjBkZjdlYTc4ODNjZTlfNHc5NG5ZYml3emVqMllLR2VEVlZXcnBwWmZraGZHa01fVG9rZW46Ym94Y25FaEdwM09rNnVhazM2QkJ2RzFGOTRaXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>究其原因，export default 导出的是一个对象，<strong>无法通过静态分析判断出一个对象的哪些变量未被使用，所以 tree-shaking 只对使用 export 导出的变量生效</strong></p>
<p>这也是函数式编程越来越火的原因，因为可以很好利用 tree-shaking 精简项目的体积，也是 vue3 全面拥抱了函数式编程的原因之一</p>
<h2 id="4、骨架屏优化白屏时长"><a href="#4、骨架屏优化白屏时长" class="headerlink" title="4、骨架屏优化白屏时长"></a>4、骨架屏优化白屏时长</h2><p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNhMWRhZTc1NzA3OWQ4NWY1Yzc1NWYyZWE5NjM5ZTJfU3dpblFiSXUzMUh6akVoUU9xVGh5QmZIdXF3MUg5MlZfVG9rZW46Ym94Y25sbHZVbXdZSzhmcGE1cmdSVDdSQTJnXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>使用骨架屏，可以缩短白屏时间，提升用户体验。国内大多数的主流网站都使用了骨架屏，特别是手机端的项目</p>
<p>SPA 单页应用，无论 vue 还是 react，最初的 html 都是空白的，需要通过加载 JS 将内容挂载到根节点上，这套机制的副作用：会造成长时间的白屏</p>
<p>常见的骨架屏插件就是基于这种原理，在项目打包时将骨架屏的内容直接放到 html 文件的根节点中</p>
<p>使用骨架屏插件，打包后的 html 文件（根节点内部为骨架屏）：</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=OTI0NmI2NmZhN2E1ODVkNWZhM2E0YjljOTg0ODZmMWRfWlRoc0F2S2hIcFZEMzI0REJmS1l5NW01ZzF3OGhSWDVfVG9rZW46Ym94Y25POUQ5cjMyMk95T3o5UFl0MTZkSWhkXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>同一项目，对比使用骨架屏前后的 FP 白屏时间：</p>
<ul>
<li>无骨架屏：白屏时间 <code>1063ms</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=YjMwZjBmOGRkMzMzYzJjNGVkMzI2NDg0YTBkZjcyZWFfN2VxU0hOVE90b21UTFAyT3JhUG1jMlZKd1E0c0ppWkNfVG9rZW46Ym94Y25sYlV5ODEzNGRTdHBDa1k4VlNZOWRjXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<ul>
<li>有骨架屏：白屏时间 <code>144ms</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2JmN2QwYWI4YzcyYjZmNjg5N2Y0NTAxZTNjM2FiZWVfNVdHSjFHN2FkdUFtM3hrOVNNSmYyTlk5Tjg3M1FKa3ZfVG9rZW46Ym94Y24xTFRhdXJ3cUJGZkkxaFFsck9IRTRkXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>骨架屏确实是优化白屏的不二选择，白屏时间缩短了 <code>86%</code></p>
<h3 id="骨架屏插件"><a href="#骨架屏插件" class="headerlink" title="骨架屏插件"></a>骨架屏插件</h3><p>这里以 <code>vue-skeleton-webpack-plugin</code> 插件为例，该插件的亮点是可以给不同的页面设置不同的骨架屏，这点确实很酷</p>
<p>1）安装</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">i</span> <span class="selector-tag">vue-skeleton-webpack-plugin</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2）vue.config.js 配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 骨架屏const SkeletonWebpackPlugin = require("vue-skeleton-webpack-plugin");</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   configureWebpack: &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">       <span class="keyword">new</span> SkeletonWebpackPlugin(&#123;</span><br><span class="line">        <span class="comment">// 实例化插件对象webpackConfig: &#123;</span></span><br><span class="line">          entry: &#123;</span><br><span class="line">            app: path.join(__dirname, <span class="string">'./src/skeleton.js'</span>) <span class="comment">// 引入骨架屏入口文件</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        minimize: <span class="literal">true</span>, <span class="comment">// SPA 下是否需要压缩注入 HTML 的 JS 代码quiet: true, // 在服务端渲染时是否需要输出信息到控制台router: &#123;</span></span><br><span class="line">          mode: <span class="string">'hash'</span>, <span class="comment">// 路由模式routes: [</span></span><br><span class="line">            <span class="comment">// 不同页面可以配置不同骨架屏// 对应路径所需要的骨架屏组件id，id的定义在入口文件内</span></span><br><span class="line">            &#123; <span class="attr">path</span>: <span class="regexp">/^\/home(?:\/)?/i</span>, <span class="attr">skeletonId</span>: <span class="string">'homeSkeleton'</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">path</span>: <span class="regexp">/^\/detail(?:\/)?/i</span>, <span class="attr">skeletonId</span>: <span class="string">'detailSkeleton'</span> &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>3）新建 skeleton .js 入口文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; skeleton.jsimport Vue from &quot;vue&quot;;</span><br><span class="line">&#x2F;&#x2F; 引入对应的骨架屏页面import homeSkeleton from &quot;.&#x2F;views&#x2F;homeSkeleton&quot;;</span><br><span class="line">import detailSkeleton from &quot;.&#x2F;views&#x2F;detailSkeleton&quot;;</span><br><span class="line"></span><br><span class="line">export default new Vue(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        homeSkeleton,</span><br><span class="line">        detailSkeleton,</span><br><span class="line">    &#125;,</span><br><span class="line">    template: &#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;homeSkeleton id&#x3D;&quot;homeSkeleton&quot; style&#x3D;&quot;display:none;&quot; &#x2F;&gt;</span><br><span class="line">      &lt;detailSkeleton id&#x3D;&quot;detailSkeleton&quot; style&#x3D;&quot;display:none;&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;,</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="5、长列表虚拟滚动"><a href="#5、长列表虚拟滚动" class="headerlink" title="5、长列表虚拟滚动"></a>5、长列表虚拟滚动</h2><p>首页中不乏有需要渲染长列表的场景，当渲染条数过多时，所需要的渲染时间会很长，滚动时还会造成页面卡顿，整体体验非常不好</p>
<p><strong>虚拟滚动——指的是只渲染可视区域的列表项，非可见区域的</strong>不渲染，在滚动时动态更新可视区域，该方案在优化大量数据渲染时效果是很明显的</p>
<p>虚拟滚动图例：</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I4OGFiMGQ3NjZkYmEwYjZmZDFjZDBkMjVlOWY2YTNfbUNpSDRSWndXVmdXRFJDdHNMWjU2M1JpUWFpNmN4S0VfVG9rZW46Ym94Y25TYzhTZE9STERTSTNiN081blJtZnlmXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>虚拟滚动基本原理：</p>
<p>计算出 totalHeight 列表总高度，并在触发时滚动事件时根据 scrollTop 值不断更新 startIndex 以及 endIndex ，以此从列表数据 listData 中截取对应元素</p>
<p>虚拟滚动性能对比：</p>
<ul>
<li>在不使用虚拟滚动的情况下，渲染 10 万个文本节点：</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=NjY2ZGQzZThlMWVjNTI0NDM5ZmQ0OGJmYTM5M2Q0Y2RfamNRUVpCUFVER1o2OE5rbDluSUlia3pCa0NIWUdRNTBfVG9rZW46Ym94Y25rRzkyN1ZGNmJDZlBEeVcwUDRZR2JjXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<ul>
<li>使用虚拟滚动的情况后：</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q3YjAwY2VjZTA1MTgzY2QzMzllOGZmZjRmODkxODRfeUtDanlkTkM4V2ZjdGgzY0hLMlYwSGNwejY2aVFYV01fVG9rZW46Ym94Y25oeHhzZlVPd3RTVGVkNTZjR3g3QXRiXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>使用虚拟滚动使性能提升了 <code>78%</code></p>
<h3 id="虚拟滚动插件"><a href="#虚拟滚动插件" class="headerlink" title="虚拟滚动插件"></a>虚拟滚动插件</h3><p>虚拟滚动的插件有很多，比如 vue-virtual-scroller、vue-virtual-scroll-list、react-tiny-virtual-list、react-virtualized 等</p>
<p>这里简单介绍 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FAkryum%2Fvue-virtual-scroller">vue-virtual-scroller</a> 的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装插件</span><br><span class="line">npm install vue-virtual-scroller</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.jsimport VueVirtualScroller from &#39;vue-virtual-scroller&#39;import &#39;vue-virtual-scroller&#x2F;dist&#x2F;vue-virtual-scroller.css&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueVirtualScroller)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;RecycleScroller</span><br><span class="line">    class&#x3D;&quot;scroller&quot;</span><br><span class="line">    :items&#x3D;&quot;list&quot;</span><br><span class="line">    :item-size&#x3D;&quot;32&quot;</span><br><span class="line">    key-field&#x3D;&quot;id&quot;</span><br><span class="line">    v-slot&#x3D;&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;user&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;RecycleScroller&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该插件主要有 RecycleScroller.vue、DynamicScroller.vue 这两个组件，其中 RecycleScroller 需要 item 的高度为静态的，也就是列表每个 item 的高度都是一致的，而 DynamicScroller 可以兼容 item 的高度为动态的情况</p>
<h2 id="6、Web-Worker-优化长任务"><a href="#6、Web-Worker-优化长任务" class="headerlink" title="6、Web Worker 优化长任务"></a>6、Web Worker 优化长任务</h2><p>由于浏览器 GUI 渲染线程与 JS 引擎线程是互斥的关系，当页面中有很多长任务时，会造成页面 UI 阻塞，出现界面卡顿、掉帧等情况</p>
<p>查看页面的长任务：</p>
<p>打开控制台，选择 Performance 工具，点击 Start 按钮，展开 Main 选项，会发现有很多红色的三角，这些就属于长任务（长任务：执行时间超过 50ms 的任务）</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYwNTYwZGM1YjJmNzhmYjdlN2IzMThlZWQ4YmNlZjRfQ3J6cVdxUVE2NTB0ejRoSkJFTjR5cXNjTG1DZlA1NDhfVG9rZW46Ym94Y25LTEZIazNFMVZhOHpVRmY1Z2t0dHpDXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>测试实验：</p>
<p>如果直接把下面这段代码直接丢到主线程中，计算过程中页面一直处于卡死状态，无法操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sum = 0;</span><br><span class="line">for (let i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">      sum += Math.random()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用 Web Worker 执行上述代码时，计算过程中页面正常可操作、无卡顿</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// worker.js</span><br><span class="line"><span class="attr">onmessage</span> = function (e) &#123;</span><br><span class="line">  // onmessage获取传入的初始值</span><br><span class="line">  let sum = e.data;</span><br><span class="line">  for (let i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">      sum += Math.random()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 将计算的结果传递出去</span><br><span class="line">  postMessage(sum);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Web Worker 具体的使用与案例，详情见 <a href="https://juejin.cn/post/7137728629986820126" target="_blank" rel="noopener">一文彻底了解 Web Worker，十万、百万条数据都是弟弟 🔥</a></p>
<h3 id="Web-Worker-的通信时长"><a href="#Web-Worker-的通信时长" class="headerlink" title="Web Worker 的通信时长"></a>Web Worker 的通信时长</h3><p>并不是执行时间超过 50ms 的任务，就可以使用 Web Worker，还要先考虑<code>通信时长</code>的问题</p>
<p>假如一个运算执行时长为 100ms，但是通信时长为 300ms， 用了 Web Worker 可能会更慢</p>
<p>比如新建一个 web worker, 浏览器会加载对应的 worker.js 资源，下图中的 Time 是这个资源的通信时长（也叫加载时长）</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=NGJhMzUzZTIzYzA4MWEyMDNjOGVlZDE1NmIyOTJlN2NfSEhMVDZHRzg3aVRxek0yenFBSE9LTE1iVlhvMUwwVVZfVG9rZW46Ym94Y25RMXM2YVlKbDUyaHNQNE9IalpjbjViXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p><strong>当任务的运算时长 - 通信时长 &gt; 50ms，推荐使用 Web Worker</strong></p>
<h2 id="7、requestAnimationFrame-制作动画"><a href="#7、requestAnimationFrame-制作动画" class="headerlink" title="7、requestAnimationFrame 制作动画"></a>7、requestAnimationFrame 制作动画</h2><p><code>requestAnimationFrame</code> 是浏览器专门为动画提供的 API，它的刷新频率与显示器的频率保持一致，使用该 api 可以解决用 setTimeout/setInterval 制作动画卡顿的情况</p>
<p>下面的案例演示了两者制作进度条的对比（运行按钮可点击）</p>
<p>可以看到使用定时器制作的动画，卡顿还是比较明显的</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>setTimeout/setInterval、requestAnimationFrame 三者的区别：</p>
<p>1）引擎层面</p>
<p>setTimeout/setInterval 属于 <code>JS引擎</code>，requestAnimationFrame 属于 <code>GUI引擎</code></p>
<p><code>JS引擎与GUI引擎</code>是互斥的，也就是说 GUI 引擎在渲染时会阻塞 JS 引擎的计算</p>
<p>2）时间是否准确</p>
<p>requestAnimationFrame 刷新频率是固定且准确的，但 setTimeout/setInterval 是宏任务，根据事件轮询机制，其他任务会阻塞或延迟 js 任务的执行，会出现定时器不准的情况</p>
<p>3）性能层面</p>
<p>当页面被隐藏或最小化时，setTimeout/setInterval 定时器仍会在后台执行动画任务，而使用 requestAnimationFrame 当页面处于未激活的状态下，屏幕刷新任务会被系统暂停</p>
<h2 id="8、JS-的-6-种加载方式"><a href="#8、JS-的-6-种加载方式" class="headerlink" title="8、JS 的 6 种加载方式"></a>8、JS 的 6 种加载方式</h2><h3 id="1）正常模式"><a href="#1）正常模式" class="headerlink" title="1）正常模式"></a>1）正常模式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br></pre></td></tr></table></figure>

<p>这种情况下 JS 会阻塞 dom 渲染，浏览器必须等待 index.js 加载和执行完成后才能去做其它事情</p>
<h3 id="2）async-模式"><a href="#2）async-模式" class="headerlink" title="2）async 模式"></a>2）async 模式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br></pre></td></tr></table></figure>

<p>async 模式下，它的加载是异步的，JS 不会阻塞 DOM 的渲染，async 加载是无顺序的，当它加载结束，JS 会立即执行</p>
<p>使用场景：若该 JS 资源与 DOM 元素没有依赖关系，也不会产生其他资源所需要的数据时，可以使用 async 模式，比如埋点统计</p>
<h3 id="3）defer-模式"><a href="#3）defer-模式" class="headerlink" title="3）defer 模式"></a>3）defer 模式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br></pre></td></tr></table></figure>

<p>defer 模式下，JS 的加载也是异步的，defer 资源会在 <code>DOMContentLoaded</code> 执行之前，并且 defer 是有顺序的加载</p>
<p>如果有多个设置了 defer 的 script 标签存在，则会按照引入的前后顺序执行，即便是后面的 script 资源先返回</p>
<p>所以 defer 可以用来控制 JS 文件的执行顺序，比如 element-ui.js 和 vue.js，因为 element-ui.js 依赖于 vue，所以必须先引入 vue.js，再引入 element-ui.js</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"element-ui.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br></pre></td></tr></table></figure>

<p>defer 使用场景：一般情况下都可以使用 defer，特别是需要控制资源加载顺序时</p>
<h3 id="4）module-模式"><a href="#4）module-模式" class="headerlink" title="4）module 模式"></a>4）module 模式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="javascript"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br></pre></td></tr></table></figure>

<p>在主流的现代浏览器中，script 标签的属性可以加上 <code>type=&quot;module&quot;</code>，浏览器会对其内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是 defer 一样，在后台下载，并且等待 DOM 解析</p>
<p>Vite 就是利用浏览器支持原生的 <code>es module</code> 模块，开发时跳过打包的过程，提升编译效率</p>
<h3 id="5）-preload"><a href="#5）-preload" class="headerlink" title="5） preload"></a>5） preload</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="preload" as="script" href="index.js"&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>link 标签的 preload 属性：用于提前加载一些需要的依赖，这些资源会优先加载（如下图红框）</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=M2RmMjI5MDg1NGYzN2FhMmNjMzM1MWViYTNjM2ExMGZfOUhlTzdWMUUwN25OV3MxMFVJdEg4VTJkWGNEM2VpeUFfVG9rZW46Ym94Y25UeDBBOVRSU0JldzZ1RWNqQzl4WkJMXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>vue2 项目打包生成的 index.html 文件，会自动给首页所需要的资源，全部添加 preload，实现关键资源的提前加载</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI1ZGFhY2RjODdiMmQ4YjY1ZWNjNmYzOWJkZmM2Y2FfRGp3aFRuUWppNUtLYVg4dnk3bDBCTWlZZ0NESklUeXFfVG9rZW46Ym94Y25rMnpMVXcwdjlENG4yQkllY0w1ZFBjXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>preload 特点：</p>
<p>1）preload 加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞 onload 事件；</p>
<p>2）preload 加载的 JS 脚本其加载和执行的过程是分离的，即 preload 会预加载相应的脚本代码，待到需要时自行调用；</p>
<h3 id="6）prefetch"><a href="#6）prefetch" class="headerlink" title="6）prefetch"></a>6）prefetch</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="prefetch" as="script" href="index.js"&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=YzU0NTJiYzJlNTExOTRhZjI0YThmZTdiZDVmMjc5YmVfbjRjS0d3TW9OVklWZHE5ZU0xMFBCTEJnUGFjM2N1T3dfVG9rZW46Ym94Y25scFppdTBrWnNBV1hXYU8xbEVlZGJoXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>prefetch 特点：</p>
<p>1）pretch 加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少 5 分钟（无论资源是否可以缓存）</p>
<p>2）当页面跳转时，未完成的 prefetch 请求不会被中断</p>
<h3 id="加载方式总结"><a href="#加载方式总结" class="headerlink" title="加载方式总结"></a>加载方式总结</h3><p>async、defer 是 script 标签的专属属性，对于网页中的其他资源，可以通过 link 的 preload、prefetch 属性来预加载</p>
<p>如今现代框架已经将 preload、prefetch 添加到打包流程中了，通过灵活的配置，去使用这些预加载功能，同时我们也可以审时度势地向 script 标签添加 async、defer 属性去处理资源，这样可以显著提升性能</p>
<h2 id="9、图片的优化"><a href="#9、图片的优化" class="headerlink" title="9、图片的优化"></a>9、图片的优化</h2><p>平常大部分性能优化工作都集中在 JS 方面，但图片也是页面上非常重要的部分</p>
<p>特别是对于移动端来说，完全没有必要去加载原图，浪费带宽。如何去压缩图片，让图片更快的展示出来，有很多优化工作可以做</p>
<p>淘宝首页的图片资源都很小：</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg4NjcwNDg5YzkyNDFiYzI4N2Q0MTdmNWVkZTAzZmVfR05lRmFkbWVKN0FaUGFEdnRMSVJ4a1o3ZmpxaEo2WUhfVG9rZW46Ym94Y241aVhSQnBqREZyZnhOSTJTRzl2SUloXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<h3 id="图片的动态裁剪"><a href="#图片的动态裁剪" class="headerlink" title="图片的动态裁剪"></a>图片的动态裁剪</h3><p>很多云服务，比如<a href="https://link.juejin.cn/?target=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F144582.html">阿里云</a>或<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.qiniu.com%2Fdora%2F3683%2Fimg-directions-for-use">七牛云</a>，都提供了图片的动态裁剪功能，效果很棒，确实是钱没有白花</p>
<p>只需在图片的 url 地址上动态添加参数，就可以得到你所需要的尺寸大小，比如：<code>http://7xkv1q.com1.z0.glb.clouddn.com/grape.jpg?imageView2/1/w/200/h/200</code></p>
<p>图片瘦身前后对比：</p>
<ul>
<li>原图：<code>1.8M</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQxYmJkZTQ5N2U2NTdkOTEyNGM0NDU0ZGM2YjhiYWZfWkVJY1NJQ1hNTlRGdWpCb3pTcVB6N0NHcnRoTnlqVTRfVG9rZW46Ym94Y25MUW15TGpuS1JaWEZQOEFQZkU1N2pnXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<ul>
<li>裁剪后：<code>12.8KB</code></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjc0NGRlNGQxMmFkOTRmMGY1OWU4YjE3NTc0MThhYmNfVk5XVENBbXhvR2NMSGRnb25yMkd1UGFDYXI1UFlPSDRfVG9rZW46Ym94Y252SGJNTlZKNkQ5OUhDNnVUeHZwOE5kXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>经过动态裁剪后的图片，加载速度会有非常明显的提升</p>
<h3 id="图片的懒加载"><a href="#图片的懒加载" class="headerlink" title="图片的懒加载"></a>图片的懒加载</h3><p>对于一些图片量比较大的首页，用户打开页面后，只需要呈现出在屏幕可视区域内的图片，当用户滑动页面时，再去加载出现在屏幕内的图片，以优化图片的加载效果</p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=YzJkNzAwYWIzNTViODZkMWUzNTQ0ZjZkYWUyMGFiMGVfRkhpdWtSWmVLa2l1aUh2cFcyazhLSWw5NHJjY3R4ZmFfVG9rZW46Ym94Y25PcnRYMllNaTJRYjMzNDdRNGJGSTlmXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>图片懒加载实现原理：</p>
<p>由于浏览器会自动对页面中的 img 标签的 src 属性发送请求并下载图片，可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src="" alt="" data-src="./images/1.jpg"&gt;</span><br><span class="line">&lt;img src="" alt="" data-src="./images/2.jpg"&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里以 <code>vue-lazyload</code> 插件为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install vue-lazyload</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 注册import VueLazyload from 'vue-lazyload'Vue.use(VueLazyload)</span></span><br><span class="line"><span class="comment">// 配置项Vue.use(VueLazyload, &#123;</span></span><br><span class="line">  preLoad: <span class="number">1.3</span>,</span><br><span class="line">  error: <span class="string">'dist/error.png'</span>, <span class="comment">// 图片加载失败时的占位图loading: 'dist/loading.gif', // 图片加载中时的占位图attempt: 1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 v-lazy 指令使用</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">"img in list"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"img.src"</span> <span class="attr">:key</span>=<span class="string">"img.src"</span> &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>&lt;<span class="regexp">/ul&gt;复制代码</span></span><br></pre></td></tr></table></figure>

<h3 id="使用字体图标"><a href="#使用字体图标" class="headerlink" title="使用字体图标"></a>使用字体图标</h3><p>字体图标是页面使用小图标的不二选择，最常用的就是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.iconfont.cn%2Fhome%2Findex">iconfont</a></p>
<p><img src="/" class="lazyload" data-src="https://e8ihplx6a2.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFjODRiNmQ1ZDhkODFjNGMyMTNhZjQwZTA5YzY2ZGVfNm1ZWktJdkpZWlJUN0lZVUt6MGlzMXpLS01aMW9yTFJfVG9rZW46Ym94Y255M0hhOWdoaTg0Rjd0bmdCelJNb2VmXzE2NzY0NTAwOTg6MTY3NjQ1MzY5OF9WNA"  alt="img"></p>
<p>字体图标的优点：</p>
<p>1）轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了 http 请求</p>
<p>2）灵活性：可以随意的改变颜色、产生阴影、透明效果、旋转等</p>
<p>3）兼容性：几乎支持所有的浏览器，请放心使用</p>
<h3 id="图片转-base64-格式"><a href="#图片转-base64-格式" class="headerlink" title="图片转 base64 格式"></a>图片转 base64 格式</h3><p>将小图片转换为 base64 编码字符串，并写入 HTML 或者 CSS 中，减少 http 请求</p>
<p>转 base64 格式的优缺点：</p>
<p>1）它处理的往往是非常小的图片，因为 Base64 编码后，图片大小会膨胀为原文件的 4/3，如果对大图也使用 Base64 编码，后者的体积会明显增加，即便减少了 http 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失</p>
<p>2）在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 http 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势</p>
<p>项目可以使用 <code>url-loader</code> 将图片转 base64：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">url-loader</span> <span class="selector-tag">--save-dev</span></span><br><span class="line"></span><br><span class="line">// 配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  <span class="selector-tag">module</span>: &#123;</span><br><span class="line">    <span class="attribute">rules</span>: [&#123;</span><br><span class="line">        test: /.(png|jpg|gif)$/i,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              // 小于 <span class="number">10</span>kb 的图片转化为 base64</span><br><span class="line">              limit: <span class="number">1024</span> * <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">     &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><p>本文主要介绍的是 <strong>代码层面</strong> 的性能优化，经过上面的一系列优化，首页打开速度有了明显的提升，虽然都是一些常规方案，但其中可以深挖的知识点并不少</p>
<p>下一篇文章： <a href="https://juejin.cn/post/7197025946918502456" target="_blank" rel="noopener">前端内存优化知多少？内存泄露只是冰山一角</a>，聊一聊前端内存方面的优化，小伙们一起来看看其中又有哪些知识点</p>
<p>参考文章： <a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_44003156%2Farticle%2Fdetails%2F107541856">路由懒加载原理及使用</a> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2FsupremeJacob%2Farticle%2Fdetails%2F116608940">vue-skeleton-webpack-plugin 骨架屏插件使用</a> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F0ea012f9a7db">前端性能优化-虚拟滚动</a> <a href="https://juejin.cn/post/6898883036222324744" target="_blank" rel="noopener">requestAnimationFrame 制作动画</a> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fjiasm%2Fp%2F7683930.html">浅谈 script 标签中的 async 和 defer</a> <a href="https://juejin.cn/post/6844903544756109319" target="_blank" rel="noopener">Tree-Shaking 性能优化实践 - 原理篇</a> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F273298222">使用 Preload&amp;Prefetch 优化前端页面的资源加载</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小黑</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2023/02/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A6%96%E9%A1%B5%E8%B5%84%E6%BA%90-%E7%99%BD%E5%B1%8F/">http://yoursite.com/2023/02/15/前端/前端性能优化-首页资源-白屏/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">小黑的小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/nest.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2023/02/15/%E5%90%8E%E7%AB%AF/SQL%E5%9F%BA%E7%A1%80/"><img class="prev_cover lazyload" data-src="/img/vue.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">后端/SQL基础</div></div></a></div><div class="next-post pull_right"><a href="/2023/02/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8C%85%E4%BD%93%E7%A7%AF/"><img class="next_cover lazyload" data-src="/img/react.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端/前端性能优化-包体积</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小黑</div><div class="footer_custom_text">Hi, welcome to my <a href="http://ynxh.xyz/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">2</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script></body></html>