<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端/你真的会用 a 标签下载吗 | 小黑的小站</title><meta name="description" content="后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载记录一下最近写的下载方法,在非同源请情况下可以将资源当成二进制的 blob 先拿到手，再进行&lt;a&gt; 的下载处理。 如果后端业务上有问题会提前抛错，这个时候需要终止下载，给予错误提示。代码如下： 1234567891011121314151617181920212223242526272829303132333435"><meta name="author" content="小黑"><meta name="copyright" content="小黑"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="前端/你真的会用 a 标签下载吗"><meta name="twitter:description" content="后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载记录一下最近写的下载方法,在非同源请情况下可以将资源当成二进制的 blob 先拿到手，再进行&lt;a&gt; 的下载处理。 如果后端业务上有问题会提前抛错，这个时候需要终止下载，给予错误提示。代码如下： 1234567891011121314151617181920212223242526272829303132333435"><meta name="twitter:image" content="http://yoursite.com/img/mysql.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="前端/你真的会用 a 标签下载吗"><meta property="og:url" content="http://yoursite.com/2024/01/31/%E5%89%8D%E7%AB%AF/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%20a%20%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E5%90%97/"><meta property="og:site_name" content="小黑的小站"><meta property="og:description" content="后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载记录一下最近写的下载方法,在非同源请情况下可以将资源当成二进制的 blob 先拿到手，再进行&lt;a&gt; 的下载处理。 如果后端业务上有问题会提前抛错，这个时候需要终止下载，给予错误提示。代码如下： 1234567891011121314151617181920212223242526272829303132333435"><meta property="og:image" content="http://yoursite.com/img/mysql.jpeg"><meta property="article:published_time" content="2024-01-31T02:40:42.880Z"><meta property="article:modified_time" content="2024-01-31T03:24:53.518Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2024/01/31/%E5%89%8D%E7%AB%AF/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%20a%20%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E5%90%97/"><link rel="prev" title="杂项/mac工具推荐" href="http://yoursite.com/2024/02/08/%E6%9D%82%E9%A1%B9/mac%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"><link rel="next" title="杂项/一套键鼠控制 win 和 mac" href="http://yoursite.com/2024/01/26/%E6%9D%82%E9%A1%B9/%E4%B8%80%E5%A5%97%E9%94%AE%E9%BC%A0%E6%8E%A7%E5%88%B6%20win%20%E5%92%8C%20mac/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://ynxh.xyz","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">127</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载"><span class="toc-number">1.</span> <span class="toc-text">后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#我真正遇到的问题，在跨域的情况下，无法正常进行下载，一直会下载一个错误的-txt-格式文件"><span class="toc-number">1.1.</span> <span class="toc-text">我真正遇到的问题，在跨域的情况下，无法正常进行下载，一直会下载一个错误的 txt 格式文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-标签-download"><span class="toc-number">1.2.</span> <span class="toc-text">a 标签 download</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装下载方法"><span class="toc-number">1.2.1.</span> <span class="toc-text">封装下载方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Firefox-不能一次点击多次下载"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Firefox 不能一次点击多次下载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#download-使用注意点"><span class="toc-number">1.2.2.</span> <span class="toc-text">download 使用注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-同源-URL-的限制"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. 同源 URL 的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-不能携带-Header"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. 不能携带 Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-download-与-Content-Disposition-的优先级"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. download 与 Content-Disposition 的优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content-Disposition"><span class="toc-number">1.3.</span> <span class="toc-text">Content-Disposition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inline"><span class="toc-number">1.3.1.</span> <span class="toc-text">inline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attachment"><span class="toc-number">1.3.2.</span> <span class="toc-text">attachment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-a-gt-标签-VS-Content-Disposition"><span class="toc-number">1.3.3.</span> <span class="toc-text">&lt;a&gt;标签 VS Content-Disposition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Blob-转换"><span class="toc-number">1.4.</span> <span class="toc-text">Blob 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法-1-用作-URL（blob-）"><span class="toc-number">1.4.1.</span> <span class="toc-text">方法 1. 用作 URL（blob:）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法-2-转换为-base64（data-）"><span class="toc-number">1.4.2.</span> <span class="toc-text">方法 2. 转换为 base64（data:）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种方法总结与对比"><span class="toc-number">1.4.3.</span> <span class="toc-text">两种方法总结与对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#responseType"><span class="toc-number">1.4.4.</span> <span class="toc-text">responseType</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content-Type-与-MIME-嗅探"><span class="toc-number">1.5.</span> <span class="toc-text">Content-Type 与 MIME 嗅探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FAQ：a-download-失效排查原因"><span class="toc-number">1.6.</span> <span class="toc-text">FAQ：a download 失效排查原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">1.8.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/mysql.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">小黑的小站</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">前端/你真的会用 a 标签下载吗</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2024-01-31 10:40:42"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2024-01-31</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2024-01-31 11:24:53"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2024-01-31</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">3.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 12 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载"><a href="#后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载" class="headerlink" title="后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载"></a>后端接口动态生成csv格式的数据，返回前端二进制数据，唤醒浏览器进行下载</h1><p>记录一下最近写的下载方法,在非同源请情况下可以将资源当成二进制的 blob 先拿到手，再进行<code>&lt;a&gt;</code> 的下载处理。</p>
<p>如果后端业务上有问题会提前抛错，这个时候需要终止下载，给予错误提示。<br>代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> downloadExcelTemplate = <span class="keyword">async</span> (_url: <span class="built_in">string</span>, _fileName?: <span class="built_in">string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ElMessage(&#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"info"</span>,</span><br><span class="line">      message: <span class="string">"即将开始下载"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> res: <span class="built_in">any</span> = <span class="keyword">await</span> request.get(&#123;</span><br><span class="line">      url: _url,</span><br><span class="line">      responseType: <span class="string">"blob"</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; res.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.data.type == <span class="string">"application/json"</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> fileExportResponseError(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ElMessage(&#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">"success"</span>,</span><br><span class="line">        message: res.msg || <span class="string">"即将开始下载"</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> url = <span class="built_in">window</span>.URL.createObjectURL(<span class="keyword">new</span> Blob([res.data]));</span><br><span class="line">      <span class="comment">// 创建一个a标签</span></span><br><span class="line">      <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">      link.href = url;</span><br><span class="line">      <span class="keyword">let</span> fileName = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">if</span> (_fileName) &#123;</span><br><span class="line">        fileName = _fileName;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从Content-Disposition中提取文件名</span></span><br><span class="line">        <span class="keyword">const</span> contentDisposition = res.headers[<span class="string">"content-disposition"</span>];</span><br><span class="line">        <span class="keyword">const</span> fileNameMatch = contentDisposition?.match(<span class="regexp">/filename\*=utf-8''([^;]+)/</span>);</span><br><span class="line">        <span class="keyword">const</span> name = fileNameMatch ? fileNameMatch[<span class="number">1</span>] : <span class="string">"模板"</span>;</span><br><span class="line">        fileName = <span class="built_in">decodeURIComponent</span>(name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      link.setAttribute(<span class="string">"download"</span>, fileName);</span><br><span class="line">      <span class="comment">// 模拟点击下载</span></span><br><span class="line">      link.click();</span><br><span class="line">      <span class="comment">// 释放URL对象</span></span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ElMessage(&#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">"warning"</span>,</span><br><span class="line">        message: res.msg || <span class="string">"下载失败"</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error :&gt;&gt; "</span>, error);</span><br><span class="line">    ElMessage(&#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"warning"</span>,</span><br><span class="line">      message: <span class="string">"下载失败"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="我真正遇到的问题，在跨域的情况下，无法正常进行下载，一直会下载一个错误的-txt-格式文件"><a href="#我真正遇到的问题，在跨域的情况下，无法正常进行下载，一直会下载一个错误的-txt-格式文件" class="headerlink" title="我真正遇到的问题，在跨域的情况下，无法正常进行下载，一直会下载一个错误的 txt 格式文件"></a>我真正遇到的问题，在跨域的情况下，无法正常进行下载，一直会下载一个错误的 txt 格式文件</h2><p>后端要设置暴露 content-disposition ，否则浏览器无法正常下载 xls 格式的文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Expose-Headers"</span>, <span class="string">"Content-Disposition"</span>)</span><br></pre></td></tr></table></figure>

<p>在排查问题的过程中，刚好也进行了这块知识的复习和深入。</p>
<p>以下文章转载自掘金 <a href="https://juejin.cn/post/7246747232997720120" target="_blank" rel="noopener">https://juejin.cn/post/7246747232997720120</a></p>
<h2 id="a-标签-download"><a href="#a-标签-download" class="headerlink" title="a 标签 download"></a>a 标签 download</h2><p>这应该是最常见，最受广大人民群众喜闻乐见的一种下载方式了，搭配上 <code>download</code> 属性， 就能让浏览器将链接的 URL 视为下载资源，而不是导航到该资源。</p>
<p>如果 <code>download</code> 再指定个 <code>filename</code> ，那么就可以在下载文件时，将其作为预填充的文件名。不过名字中的 <code>/</code> 和 <code>\</code> 会被转化为下划线 <code>_</code>，而且文件系统可能会阻止文件名中的一些字符，因此浏览器会在必要时适当调整文件名。</p>
<h3 id="封装下载方法"><a href="#封装下载方法" class="headerlink" title="封装下载方法"></a>封装下载方法</h3><p>贴份儿我常用的下载方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadByUrl = <span class="function">(<span class="params">url: <span class="built_in">string</span>, filename: <span class="built_in">string</span></span>) =&gt;</span> &#123; <span class="keyword">if</span> (!url) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'当前没有下载链接'</span>); <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>); a.style.display = <span class="string">"none"</span>; a.href = url; a.download = filename; <span class="comment">// 使用target="_blank"时，添加rel="noopener noreferrer" 堵住钓鱼安全漏洞 防止新页面window指向之前的页面 a.rel = "noopener noreferrer"; document.body.append(a); a.click(); setTimeout(() =&gt; &#123; a.remove(); &#125;, 1000); &#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="Firefox-不能一次点击多次下载"><a href="#Firefox-不能一次点击多次下载" class="headerlink" title="Firefox 不能一次点击多次下载"></a>Firefox 不能一次点击多次下载</h4><p>这里有个兼容性问题：在火狐浏览器中，当一个按钮同时下载多个文件（调用多次）时，只能下载第一个文件。所以，我们可以利用 <code>&lt;a&gt;</code> 标签的 <code>target</code> 属性，将其设置成 <code>_blank</code> 让火狐在一个新标签页中继续下载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查浏览器型号和版本 const useBrowser = () =&gt; &#123; const ua = navigator.userAgent.toLowerCase(); const re = /(msie|firefox|chrome|opera|version).*?([\d.]+)/; const m = ua.match(re); const Sys = &#123; browser: m[1].replace(/version/, "'safari"), version: m[2] &#125;; return Sys; &#125;;</span></span><br></pre></td></tr></table></figure>

<p>添加一个浏览器判断：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadByUrl = <span class="function">(<span class="params">url: <span class="built_in">string</span>, filename: <span class="built_in">string</span></span>) =&gt;</span> &#123; <span class="comment">// 略...... // 火狐兼容 if (useBrowser().browser === "firefox") &#123; a.target = "_blank"; &#125; document.body.append(a); &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="download-使用注意点"><a href="#download-使用注意点" class="headerlink" title="download 使用注意点"></a>download 使用注意点</h3><p><code>&lt;a&gt;</code> 标签虽好，但还有一些值得注意的点：</p>
<h4 id="1-同源-URL-的限制"><a href="#1-同源-URL-的限制" class="headerlink" title="1. 同源 URL 的限制"></a>1. 同源 URL 的限制</h4><blockquote>
<p>download 只在同源 URL 或 <code>blob:</code> 、 <code>data:</code> 协议起作用</p>
</blockquote>
<p>也就是说跨域是下载不了的……（这种说法不全对，除非后端配置 Content-Disposition 为 attachment，后面会讲）</p>
<p>首先，非同源 URL 会进行导航操作。其次，如果非要下载，那么正如上面的文档所说，可以先将其转换为 <code>blob:</code> 或 <code>data:</code> 再进行下载，至于如何转换会在 <code>Blob</code> 章节中详细介绍。</p>
<h4 id="2-不能携带-Header"><a href="#2-不能携带-Header" class="headerlink" title="2. 不能携带 Header"></a>2. 不能携带 Header</h4><p>使用 <code>&lt;a&gt;</code> 标签下载是带不了 <code>Header</code> 的，因此不能通过添加请求表头的形式来鉴权，但是可以将 <code>sessionid</code> 或 <code>token</code> 字段拼接到 URL 末尾来达到鉴权的目的。这里我们给出另一个解决方案：</p>
<ol>
<li>先发送请求获取 <code>blob</code> 文件流，这样就能在请求时进行鉴权；</li>
<li>鉴权通过后再执行下载操作。</li>
</ol>
<p>这样是不是就能很好的同时解决问题 1 和问题 2 带来的两个痛点了呢，而且下载的文件名也能自定义了 😃</p>
<p>顺便提一下，<code>location.href</code> 和 <code>window.open</code> 也存在<a href="https://juejin.cn/post/7156427561302982670#heading-1" target="_blank" rel="noopener" title="https://juejin.cn/post/7156427561302982670#heading-1">同样的问题</a>。</p>
<h4 id="3-download-与-Content-Disposition-的优先级"><a href="#3-download-与-Content-Disposition-的优先级" class="headerlink" title="3. download 与 Content-Disposition 的优先级"></a>3. download 与 Content-Disposition 的优先级</h4><p>这里需要关注一个响应标头 <code>Content-Disposition</code>。在同源情况下（非同源 download 直接无效，没有可比性），它会影响 <code>&lt;a&gt;</code>的 <code>download</code> 从而可能产生不同的下载行为，先看一个真实下载链接的 <code>Response Headers</code>：</p>
<p><img src="/" class="lazyload" data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1a3ed67530b48aaa2a00af74e6bf0dc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=677&h=146&s=12046&e=png&b=ffffff"  alt="Snipaste_2023-06-20_18-19-21.png"></p>
<p>如图所示，<code>Content-Disposition</code> 的 value 值为 <code>attachment;filename=aaaa.bb</code>。请记住，此时 <strong>Content-Disposition 的 filename 优先级会大于 <code>&lt;a&gt;</code> download 的优先级</strong>。也就是说，当两者都指定了 <code>filename</code> 时，会优先使用 <code>Content-Disposition</code> 中的文件名。</p>
<p>接下来我们看看这个响应标头到底是什么。</p>
<h2 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h2><blockquote>
<p>在常规的 HTTP 应答中，Content-Disposition 响应标头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。</p>
</blockquote>
<p>与 <code>Content-Type</code> 不同，后者用来指示资源的 MIME 类型，比如资源是图片（<code>image/png</code>）还是一段 JSON（<code>application/json</code>），而 <code>Content-Disposition</code> 则是用来指明该资源是直接展示在页面上的，还是应该当成附件下载保存到本地的。</p>
<p>当它作为 HTTP 消息主题的标头时，有以下三种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: inline Content-Disposition: attachment Content-Disposition: attachment; filename&#x3D;&quot;filename.jpg&quot;</span><br></pre></td></tr></table></figure>

<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>默认值，即指明资源是直接展示在页面上的。 但是在同源 URL 情况下，<code>&lt;a&gt;</code> 元素的 <code>download</code> 属性优先级比 <code>inline</code> 大，浏览器优先使用 <code>download</code> 属性来处理下载（Firefox 早期版本除外）。</p>
<h3 id="attachment"><a href="#attachment" class="headerlink" title="attachment"></a>attachment</h3><p>即指明资源应该被下载到本地，大多数浏览器会呈现一个 “保存为” 的对话框，如果此时后面还有 <code>filename</code>，那么它将其优于 <code>download</code> 属性成为下载的预填充文件名。</p>
<p><strong>它的优先级最高</strong>。</p>
<p>此时，无论是  <strong>a 标签跳转</strong>、<strong>location.href 导航</strong>、<strong>window.open 打开新页面</strong>、<strong>直接在地址栏上输入 URL</strong>  等，其结果：</p>
<p>都可以实现下载！</p>
<p>都可以实现下载！</p>
<p>都可以实现下载！</p>
<h3 id="lt-a-gt-标签-VS-Content-Disposition"><a href="#lt-a-gt-标签-VS-Content-Disposition" class="headerlink" title="&lt;a&gt;标签 VS Content-Disposition"></a><code>&lt;a&gt;</code>标签 VS Content-Disposition</h3><p>介绍完 <code>Content-Disposition</code>，我们做一个横向比对的归纳一下：</p>
<ul>
<li><p><code>download</code> VS <code>inline/attachment</code></p>
<p>优先级：<code>attachment</code> &gt; <code>download</code> &gt; <code>inline</code></p>
</li>
<li><p><code>download</code> 的值 VS <code>attachment</code> 的值（指 filename）</p>
<p>优先级：<code>attachment</code> 的值 &gt; <code>download</code> 的值</p>
</li>
</ul>
<h2 id="Blob-转换"><a href="#Blob-转换" class="headerlink" title="Blob 转换"></a>Blob 转换</h2><p>前文介绍到，在非同源请情况下可以将资源当成二进制的 blob 先拿到手，再进行 <code>&lt;a&gt;</code> 的下载处理。接下来，我们介绍两种 blob 的操作：</p>
<h3 id="方法-1-用作-URL（blob-）"><a href="#方法-1-用作-URL（blob-）" class="headerlink" title="方法 1. 用作 URL（blob:）"></a>方法 1. 用作 URL（blob:）</h3><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FURL%2FcreateObjectURL_static" title="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL_static">URL.createObjectURL</a> 可以给 <code>File</code> 或 <code>Blob</code> 生成一个 URL，形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>，此时浏览器内部就会为每个这样的 URL 存储一个 URL → Blob 的映射。因此，此类 URL 很短，但可以访问 Blob。</p>
<p>那这就好办多了，写成代码就三行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> downloadByUrl <span class="keyword">from</span> <span class="string">"@/utils/download"</span>; <span class="keyword">const</span> download = <span class="keyword">async</span> () =&gt; &#123; <span class="keyword">const</span> blob = <span class="keyword">await</span> fetchFile(); <span class="comment">// 生成访问 blob 的 URL const url = URL.createObjectURL(blob); // 调用刚刚封装的 a 标签下载方法 downloadByUrl(url, "表格文件.xlsx"); // 删除映射，释放内存 URL.revokeObjectURL(url); &#125;;</span></span><br></pre></td></tr></table></figure>

<p>不过它有个副作用。虽然这里有  <code>Blob</code>  的映射，但  <code>Blob</code>  本身只保存在内存中的。浏览器无法释放它。</p>
<p>在文档退出时（unload），该映射会被自动清除，因此  <code>Blob</code>  也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。</p>
<p><strong>因此，如果我们创建一个 URL，那么即使我们不再需要该  <code>Blob</code>  了，它也会被挂在内存中。</strong></p>
<p>不过，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FURL%2FrevokeObjectURL_static" title="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL_static">URL.revokeObjectURL</a> 可以从内部映射中移除引用，允许  <code>Blob</code>  被删除并释放内存。所以，在即时下载完资源后，不要忘记立即调用 URL.revokeObjectURL。</p>
<h3 id="方法-2-转换为-base64（data-）"><a href="#方法-2-转换为-base64（data-）" class="headerlink" title="方法 2. 转换为 base64（data:）"></a>方法 2. 转换为 base64（data:）</h3><p>作为 <code>URL.createObjectURL</code>  的一个替代方法，我们也可以将  Blob  转换为 base64-编码的字符串。这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读”。</p>
<p>更重要的是 —— 我们可以在 “data-url” 中使用此编码。<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh%2Fdocs%2FWeb%2Fhttp%2FData_URIs" title="https://developer.mozilla.org/zh/docs/Web/http/Data_URIs">“data-url”</a>  的形式为  <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code>。我们可以在任何地方使用这种 url，和使用“常规” url 一样。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFileReader" title="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader</a> 是一个对象，其<strong>唯一目的</strong>就是从 Blob 对象中读取数据，我们可以使用它的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFileReader%2FreadAsDataURL" title="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL">readAsDataURL</a> 方法将 Blob 读取为 base64。请看以下示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> downloadByUrl <span class="keyword">from</span> <span class="string">"@/utils/download"</span>; <span class="keyword">const</span> download = <span class="keyword">async</span> () =&gt; &#123; <span class="keyword">const</span> blob = <span class="keyword">await</span> fetchFile(); <span class="comment">// 声明一个 fileReader const fileReader = new FileReader(); // 将 blob 读取成 base64 fileReader.readAsDataURL(blob); // 读取成功后 下载资源 fileReader.onload = function () &#123; downloadByUrl(fileReader.result); &#125;; &#125;;</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们先实例化了一个 <code>fileReader</code>，用它来读取 blob。</p>
<p>一旦读取完成，就可以从 fileReader 的 <code>result</code> 属性中拿到一个<code>data: URL</code> 格式的 Base64 字符串。</p>
<p>最后，我们给 fileReader 注册了一个 <code>onload</code> 事件，在读取操作完成后开始下载。</p>
<h3 id="两种方法总结与对比"><a href="#两种方法总结与对比" class="headerlink" title="两种方法总结与对比"></a>两种方法总结与对比</h3><p><code>URL.createObjectURL(blob)</code> 可以直接访问，无需“编码/解码”，但需要记得撤销（revoke）；</p>
<p>而 <code>Data URL</code> 无需撤销（revoke）任何操作，但对大的  <code>Blob</code>  进行编码时，性能和内存会有损耗。</p>
<p>总而言之，这两种从  <code>Blob</code>  创建 URL 的方法都可以用。但通常  <code>URL.createObjectURL(blob)</code>  更简单快捷。</p>
<h3 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h3><p>最后，我们回头说一下请求的注意点：如果你的项目使用的是 <code>XHR</code> （比如 axios）而不是 <code>fetch</code>， 那么请记得在请求时添加上 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2FresponseType" title="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType">responseType</a> 为 ‘blob’。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchFile = <span class="keyword">async</span> params =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(api, &#123; params, <span class="attr">responseType</span>: <span class="string">"blob"</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>responseType</code> 不是 axios 中的属性，而是 <code>XMLHttpRequest</code> 中的属性，它用于指定响应中包含的数据类型，当为 “blob” 时，表明 <code>Response</code> 是一个包含二进制数据的  <code>Blob</code> 对象。</p>
<p>除了 <code>blob</code> 之外，responseType 还有 <code>arraybuffer</code>、<code>json</code>、<code>text</code>等其他枚举字符串值。</p>
<h2 id="Content-Type-与-MIME-嗅探"><a href="#Content-Type-与-MIME-嗅探" class="headerlink" title="Content-Type 与 MIME 嗅探"></a>Content-Type 与 MIME 嗅探</h2><p>看到这里，你可能会觉得很麻烦：什么乱七八槽的，我做需求的时候不需要搞这些花里胡哨的东西啊，直接一个 <code>window.open()</code> 或者 <code>location.href</code> 就可以直接下载了，也没有看到链接上有写什么 <code>Content-Dispoistion</code> 呀！</p>
<p><img src="/" class="lazyload" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eb142c6daf543edaee4f0e480e743e8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=248&h=185&s=10767&e=gif&f=2&b=f8f6f6"  alt="132U330G-0.gif"></p>
<p>恭喜你，遇到了一个好后端~</p>
<p>的确，在有些情况下，即使不指定 <code>Content-Dispoistion</code> 依然能够以最简单的方式直接下载。比如，这个下载链接：</p>
<p><img src="/" class="lazyload" data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24cf5ba9a2054736b61fd935adc2e2a9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=915&h=469&s=40798&e=png&b=ffffff"  alt="excel.png"></p>
<p>当使用 <code>window.open()</code> 或 <code>location.href</code> 发起一个 <code>Doc</code> 类型的请求时（<strong>注意，不是 <code>Fetch/XHR</code> 类型</strong>），浏览器便会自动下载 <code>.xlsx</code> 格式的 <code>excel</code> 文件。</p>
<p>这是因为 <code>Content-Type</code> 被设置成了 <code>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code>，表示返回的内容是扩展名为 <code>.xlsx</code> 且文档类型为 <code>Microsoft Excel (OpenXML)</code> 的资源。</p>
<p>除了 Excel 还有 Word、PPT，它们都有自己特定的 MIME 类型：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>文档类型</th>
<th>MIME 类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>.doc</code></td>
<td>Microsoft Word</td>
<td>application/msword</td>
</tr>
<tr>
<td><code>.docx</code></td>
<td>Microsoft Word (OpenXML)</td>
<td>application/vnd.openxmlformats-officedocument.wordprocessingml.document</td>
</tr>
<tr>
<td><code>.xls</code></td>
<td>Microsoft Excel</td>
<td>application/vnd.ms-excel</td>
</tr>
<tr>
<td><code>.xlsx</code></td>
<td>Microsoft Excel (OpenXML)</td>
<td>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td>
</tr>
<tr>
<td><code>.ppt</code></td>
<td>Microsoft PowerPoint</td>
<td>application/vnd.ms-powerpoint</td>
</tr>
<tr>
<td><code>.pptx</code></td>
<td>Microsoft PowerPoint (OpenXML)</td>
<td>application/vnd.openxmlformats-officedocument.presentationml.presentation</td>
</tr>
</tbody></table>
<p>正是这些类型，才触发了浏览器的下载行为。当然，不同的浏览器行为可能不一样。</p>
<p>那如果连 <code>Content-Type</code> 都没有设置呢？</p>
<blockquote>
<p>在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行  <strong>MIME 嗅探</strong>。</p>
<p>每一个浏览器在不同的情况下会执行不同的操作。（例如，Safari 会在发送的 MIME 类型不合适时查看文件的扩展名。）由于某些 MIME 类型可能代表可执行内容，会存在一些安全问题。</p>
</blockquote>
<p>也就是说，此时浏览器便会自行猜测并设置 MIME 类型。但是这样做是不规范且不安全的，为了防止这种行为，后端可以设置  <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FX-Content-Type-Options" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a>  为  <code>nosniff</code>。</p>
<p>至于为什么需要避免浏览器嗅探，感兴趣的同学可以查看 👉 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FLearn%2FServer-side%2FConfiguring_server_MIME_types%23%25E4%25B8%25BA%25E4%25BD%2595%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E4%25B8%258D%25E5%25BA%2594%25E8%25AF%25A5%25E7%258C%259C%25E6%25B5%258B_mime_%25E7%25B1%25BB%25E5%259E%258B" title="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Configuring_server_MIME_types#%E4%B8%BA%E4%BD%95%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E5%BA%94%E8%AF%A5%E7%8C%9C%E6%B5%8B_mime_%E7%B1%BB%E5%9E%8B">为何浏览器不应该猜测 MIME 类型</a>。</p>
<h2 id="FAQ：a-download-失效排查原因"><a href="#FAQ：a-download-失效排查原因" class="headerlink" title="FAQ：a download 失效排查原因"></a>FAQ：a download 失效排查原因</h2><p>原因一：因为跨域，真的失效了；</p>
<p>原因二：生效了，但被 Dispoistion 的 filename 给覆盖了；</p>
<p>解决思路：参考总结 👇</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>Content-Disposition</code> 为 <code>attachment</code>，无论哪种方式，都能直接下载；<ul>
<li>优点：方便；</li>
<li>缺点：如果指定了 filename，优先级最高，前端无法直接修改文件名，除非转 <code>blob:</code> 或 <code>data:</code> 再利用 a download 下载并修改</li>
</ul>
</li>
<li><code>Content-Disposition</code> 没有设置（默认 <code>inline</code>）<ul>
<li>同源直接使用 <code>&lt;a&gt; download</code> 下载；</li>
<li>跨域就先获取 <code>blob</code>，用 <code>createObjectURL</code> 或 <code>readAsDataURL</code> 读取链接，再用 <code>&lt;a&gt; download</code> 下载。</li>
</ul>
</li>
<li>有些特殊格式的资源（比如 Excel 表格），只需正确设置对应的 <code>Content-Type</code>，即可通过 <code>Doc</code> 类型的 HTTP 请求直接触发浏览器的下载行为。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTML%2FElement%2Fa" title="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a"><code>&lt;a&gt;</code>锚元素 | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Disposition" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition">Content-Disposition | MDN</a></li>
<li><a href="https://juejin.cn/post/7207078219215732794#heading-14" target="_blank" rel="noopener" title="https://juejin.cn/post/7207078219215732794#heading-14">PDF 预览和下载你是怎么实现的</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzh.javascript.info%2Fblob" title="https://zh.javascript.info/blob">Blob | 现代 JavaScript 教程</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FURL%2FcreateObjectURL_static" title="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL_static">URL.createObjectURL | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FURL%2FrevokeObjectURL_static" title="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL_static">URL.revokeObjectURL | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FData_URLs" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">Data URL | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFileReader" title="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2FresponseType" title="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType">XMLHttpRequest.responseType | MDN</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fjann8%2Fp%2F17472129.html" title="https://www.cnblogs.com/jann8/p/17472129.html">HTTP 的几种类型</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types%2FCommon_types" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types">常见 MIME 类型表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.iana.org%2Fassignments%2Fmedia-types%2Fmedia-types.xhtml" title="https://www.iana.org/assignments/media-types/media-types.xhtml">MIME types 列表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types%23mime_%25E5%2597%2585%25E6%258E%25A2" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_%E5%97%85%E6%8E%A2">MIME 嗅探</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FX-Content-Type-Options" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options">X-Content-Type-Options</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小黑</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2024/01/31/%E5%89%8D%E7%AB%AF/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%20a%20%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E5%90%97/">http://yoursite.com/2024/01/31/前端/你真的会用 a 标签下载吗/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">小黑的小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/vue.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2024/02/08/%E6%9D%82%E9%A1%B9/mac%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"><img class="prev_cover lazyload" data-src="/img/vue.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">杂项/mac工具推荐</div></div></a></div><div class="next-post pull_right"><a href="/2024/01/26/%E6%9D%82%E9%A1%B9/%E4%B8%80%E5%A5%97%E9%94%AE%E9%BC%A0%E6%8E%A7%E5%88%B6%20win%20%E5%92%8C%20mac/"><img class="next_cover lazyload" data-src="/img/react.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">杂项/一套键鼠控制 win 和 mac</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小黑</div><div class="footer_custom_text">Hi, welcome to my <a href="http://ynxh.xyz/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">2</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script></body></html>